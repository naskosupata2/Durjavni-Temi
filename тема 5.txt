                                           Реализиране на собствени линейни структури от данни Тема-5


1-Линейна структура от данни е структура, която представлява последователност от елементи, където всеки елемент има само един предшественик и един наследник. Примери за линейни структури от данни са масиви и списъци. Алгоритмите за търсене в линейни структури от данни са методи за намиране на определен елемент в последователността. Примери за търсещи алгоритми са линейното търсене и бинарното търсене. Алгоритмите за сортиране в линейни структури от данни са методи за подреждане на елементите в последователността по определен начин. Примери за сортиращи алгоритми са сортиране чрез сливане, бързо сортиране и вмъкване.

2-Един от основните видове алгоритми за търсене е линейното търсене. При линейното търсене се обхожда елемент по елемент от началото до края на структурата, за да се намери търсеният елемент. Ако елементът се намира в структурата, то търсенето приключва успешно, в противен случай се връща съобщение за неуспех.

Един от по-ефективните алгоритми за търсене е бинарното търсене. Той предполага, че структурата е сортирана във възходящ ред. Алгоритъмът работи по следния начин:

Намира средния елемент на структурата
Сравнява търсения елемент със средния елемент
Ако търсеният елемент е равен на средния елемент, търсенето приключва успешно
Ако търсеният елемент е по-малък от средния елемент, търсенето продължава в лявата половина на структурата
Ако търсеният елемент е по-голям от средния елемент, търсенето продължава в дясната половина на структурата
Ако стигнем до край на структурата без да сме намерили търсения елемент, търсенето приключва неуспешно.
Ето примерна имплементация на бинарно търсене на елемент в сортиран масив от цели числа в езика C#:

public static int FindMedian(int[] arr)
{
    Array.Sort(arr); // сортиране на масива
    int middleIndex = arr.Length / 2; // индексът на средния елемент
    int median = arr[middleIndex]; // средният елемент
    
    if (arr.Length % 2 == 0) // ако има четен брой елементи
    {
        median = (arr[middleIndex - 1] + arr[middleIndex]) / 2;
    }
    
    return median;
}

Този метод използва вградената функция Array.Sort за сортиране на масива и намира средния елемент, като проверява дали масивът има четен или нечетен брой елементи. Ако има четен брой елементи, средният елемент е средната стойност между двата централни елемента. В противен случай, средният елемент е точно този, който е на средата.

3- Статичната реализация на линейна структура от данни предвижда предварително зададена големина на структурата и фиксиран брой елементи. Това означава, че не може да се добавят или премахват елементи след инициализацията на структурата. Пример за статична реализация на линейна структура от данни е масивът в езиците за програмиране.

Динамичната реализация на линейна структура от данни позволява добавянето и премахването на елементи по време на изпълнение на програмата. Това се постига чрез използването на софтуерни структури като свързан списък, стек, опашка и др. Пример за динамична реализация на линейна структура от данни е LinkedList в C#.

И двата вида реализации имат своите предимства и недостатъци и се избират според нуждите на програмата и изискванията на конкретната задача.

Статичната реализация на линейни структури от данни използва статичен масив с фиксиран размер, който не може да бъде променен по време на изпълнение на програмата. Динамичната реализация използва свързан списък, който може да бъде променян по време на изпълнение на програмата. Разтегливият масив е динамична реализация на масив, който може да бъде увеличаван или намаляван по време на изпълнение на програмата. Реализацията на стек и опашка може да бъде осъществена чрез разтеглив масив или свързан списък. Двойно свързаният списък е свързан списък, който има връзки към предишния и следващия елемент в списъка.

При статична реализация на линейните структури от данни (като например разтеглив масив) операциите за добавяне и изтриване на елементи са по-бавни, тъй като се налага да се пренареждат елементите в масива, ако няма достатъчно място или ако се изтрие някой елемент. В този случай може да се налага да се копират големи блокове от памет, което може да доведе до забавяне на изпълнението.

При динамична реализация на линейните структури от данни (като например свързан списък или двойно свързан списък) операциите за добавяне и изтриване на елементи са по-бързи, тъй като не се налага да се пренареждат елементите в масив, а просто се пренасочват указателите към новите елементи. Това може да бъде по-ефективно, особено ако имаме много малко или много големи елементи. От друга страна, обхождането на елементите в свързан списък може да е по-бавно, тъй като се налага да се обработва всеки елемент поотделно.

4-Алгоритмите за сортиране са един от основните инструменти в програмирането и компютърните науки. Те ни позволяват да подредим елементите в линейна структура от данни (масив, списък и др.) в нарастващ или намаляващ ред. В следващите редове ще дадем общо описание на някои от най-популярните алгоритми за сортиране и ще демонстрираме тяхната имплементация на примерни програми на езика C#.

Сортиране чрез пряка селекция (Selection Sort) - при този алгоритъм на всяка стъпка намираме най-малкия елемент и го разменяме с първия елемент в списъка. Това продължава за всички елементи, освен последния, докато списъкът не стане сортиран.
Пример за имплементация на сортиране чрез пряка селекция на масив от цели числа:

static void SelectionSort(int[] arr)
{
    int n = arr.Length;
    // обхождаме всички елементи
    for (int i = 0; i < n - 1; i++)
    {
        int min_idx = i;
        // намираме най-малкия елемент в остатъка от списъка
        for (int j = i + 1; j < n; j++)
        {
            if (arr[j] < arr[min_idx])
            {
                min_idx = j;
            }
        }
        // разменяме текущия елемент с най-малкия
        int temp = arr[min_idx];
        arr[min_idx] = arr[i];
        arr[i] = temp;
    }
}
Сортиране чрез метода на мехурчето (Bubble Sort) - този алгоритъм сравнява последователно всеки два съседни елемента и ги разменя, ако не са в правилния ред. Това продължава докато списъкът не бъде сортиран.

Пример за имплементация на сортиране чрез метода на мехурчето на масив от цели числа:

public static void BubbleSort(int[] arr)
{
    int n = arr.Length;
    for (int i = 0; i < n - 1; i++)
    {
        for (int j = 0; j < n - i - 1; j++)
        {
            if (arr[j] > arr[j + 1])
            {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

Този алгоритъм работи като сравнява последователни двойки елементи на масива и разменя позициите им, ако първият елемент е по-голям от втория. Този процес продължава докато масивът е напълно сортиран.

5-Рекурсия е процес, при който функция се извиква сама със сходни аргументи, докато не бъде достигнат определен крайен условен случай. Това означава, че рекурсивна функция може да се дефинира като комбинация от базов случай и индуктивен случай.

Пример за рекурсивна функция е факториел на дадено число. Факториелът на дадено число n се дефинира като произведението на всички цели числа от 1 до n. Можем да дефинираме факториела n! рекурсивно като:

n! = n * (n-1) * (n-2) * ... * 1
n! = n * (n-1)!

Използвайки тези дефиниции, можем да напишем следната рекурсивна функция за намиране на факториел:

public int Factorial(int n)
{
    if (n == 0)
    {
        return 1; // базов случай
    }
    else
    {
        return n * Factorial(n - 1); // индуктивен случай
    }
}

Тази функция използва базовия случай, когато n = 0, и индуктивния случай, когато n > 0. Идеята е, че функцията се извиква рекурсивно с
n - 1, докато стигне до базовия случай n = 0.

Рекурсията се използва често в програмирането, защото може да се използва за решаване на сложни проблеми, които не могат да бъдат решени по пряк или итеративен начин. Например, рекурсивното търсене на елемент в дърво е често приложение на рекурсията в програмирането.
