                                                    Алгоритми и структури от данни Тема-18

1-Алчен алгоритъм е алгоритъм, който винаги избира най-доброто възможно решение в даден момент, без да се интересува от последиците в бъдеще. Такъв алгоритъм може да доведе до оптимални решения в някои случаи, но не винаги.

Един пример за алчен алгоритъм е алгоритъмът на Дейкстра за намиране на най-къс път в граф. Той избира най-малкото разстояние от началната точка до всяка друга точка в графа във всеки момент, без да взема предвид дали това ще доведе до най-краткия път към краен връх. Въпреки че алгоритъмът на Дейкстра може да даде правилни резултати в много случаи, има и сценарии, в които той не дава оптимални решения.

Друг пример за алчен алгоритъм е алгоритъмът на сортиране на масива чрез избор на най-малкия елемент на всяка стъпка и поставянето му на правилната позиция. Този алгоритъм може да бъде ефективен за малки масиви, но е много бавен за големи масиви и има много по-ефективни алгоритми за сортиране на масиви, като бързо сортиране и сливане на масиви.

В общия случай, алчните алгоритми могат да бъдат полезни в някои приложения, но трябва да бъдат използвани с оглед на конкретната задача и да се избягват при нужда от оптимални решения.

2-Рекурсията е техника в програмирането, при която функцията се извиква сама себе си, докато не бъде изпълнено някакво условие за прекъсване на рекурсията. Това позволява решаването на много сложни проблеми, като се използва по-прост начин за решаване на проблема, когато е възможно.

Пример за рекурсивен алгоритъм с пълно изчерпване е генерирането на всички пермутации на множество от елементи. Ако имаме множество от елементи, можем да генерираме всички пермутации чрез рекурсивна функция, която генерира всички възможни пермутации на първите N-1 елемента, като прилепва N-тия елемент на всяка една от тези пермутации. Това продължава, докато се използват всички елементи, и всички пермутации се генерират. Това е пример за рекурсивен алгоритъм с пълно изчерпване, тъй като изчерпва всички възможни комбинации от елементи в множеството.

3-Ето един пример за програма, която решава задачата за раницата с помощта на алчен алгоритъм:


def knapsack(items, capacity):
    """
    Решава задачата за раницата с помощта на алчен алгоритъм.

    :param items: списък от двойки (име, тегло, стойност) на предметите
    :param capacity: капацитет на раницата
    :return: списък от двойки (име, тегло, стойност) на избраните предмети
    """
    # Сортираме предметите в намаляващ ред спрямо тяхната стойност/тегло
    items = sorted(items, key=lambda x: x[2] / x[1], reverse=True)

    selected_items = []
    remaining_capacity = capacity

    # Обхождаме всички предмети в реда, в който са сортирани
    for item in items:
        # Ако можем да вземем целия предмет, го добавяме към избраните
        if item[1] <= remaining_capacity:
            selected_items.append(item)
            remaining_capacity -= item[1]
        # Иначе вземаме само част от него, пропорционално на останалия капацитет
        else:
            fraction = remaining_capacity / item[1]
            selected_items.append((item[0], item[1] * fraction, item[2] * fraction))
            break

    return selected_items
Функцията knapsack приема списък items от предмети, като всеки предмет е представен чрез кортеж от име, тегло и стойност. Тя приема също капацитет capacity на раницата. Функцията използва алчен алгоритъм за да избере максималния брой предмети, които да побере раницата, като за целта сортира предметите в намаляващ ред спрямо тяхната стойност/тегло и след това обхожда списъка от предмети, добавяйки ги към списъка selected_items, докато не стигне до капацитета на раницата. Ако има предмети, които не могат да бъдат взети цели, функцията взема част от тях, пропорционално на останалия капацитет.

4-В комбинаториката, вариациите, комбинациите и пермутациите са трите основни понятия, свързани с избора на елементи от определено множество.

Вариациите представляват броя на възможните наредби, в които могат да се подредят k елемента от n. Те се обозначават като V(n,k) и имат стойност: V(n,k) = n! / (n - k)!. Например, ако имаме множество {a,b,c} и искаме да изберем 2 елемента, възможните вариации ще бъдат: ab, ac, ba, bc, ca, cb.

Комбинациите представляват броя на възможните комбинации на k елемента от n, без значение от реда. Те се обозначават като С(n,k) и имат стойност: С(n,k) = n! / (k! * (n - k)!). Например, ако имаме множество {a,b,c} и искаме да изберем 2 елемента, възможните комбинации ще бъдат: ab, ac, bc.

Пермутациите представляват броя на възможните наредби, в които могат да се подредят всички елементи от дадено множество. Те се обозначават като P(n) и имат стойност: P(n) = n!. Например, ако имаме множество {a,b,c}, възможните пермутации ще бъдат: abc, acb, bac, bca, cab, cba.

Различаването между тези понятия е свързано с наредбата и броя на елементите, които избираме. Ако е важна наредбата и избираме по-малко от всички елементи, говорим за вариации. Ако наредбата не е важна и избираме по-малко от всички елементи, говорим за комбинации. Ако наредбата е важна и избираме всички елементи, говорим за пермутации.

5-Динамичното оптимиране (dynamic programming) е техника за решаване на проблеми от областта на оптимизацията и алгоритмите, която се базира на запазването на промеждинни резултати и използването им при по-нататъшните изчисления.

Идеята зад динамичното оптимиране е да се избегнат повтарящи се изчисления на едни и същи стойности в различни части от алгоритъма, като се запазват в променливи или таблица. Тези промеждинни резултати след това се използват при изчислението на други стойности. Това позволява да се намали броя на изчисленията и да се постигне по-бързо и ефективно решение на проблема.

Динамичното оптимиране се използва в много области на компютърните науки, като например в задачите за намиране на най-дълга обща подпоследователност, оптимален път в граф, максимален подмасив и други.

6-Ето пример за решаване на задачата за най-малка подредица с помощта на техниките на динамичното оптимиране:

Дадени са два низа, например "ABCD" и "AEBD". Целта е да се намери най-малката обща подредица на символите на двете низа, като редът на символите да се запази. В този случай, най-малката обща подредица е "ABD".

За да се реши тази задача, можем да използваме техниката на динамичното оптимиране. Ще започнем със създаване на таблица с размерност (n+1)x(m+1), където n е дължината на първия низ, а m е дължината на втория низ. Таблицата ще съдържа резултатите от най-малките общи подредици за всички поднизове от двете низа.

Започваме с попълването на първия ред и първа колона на таблицата. Първият ред от таблицата ще отразява най-малката обща подредица на първия низ и празен низ. Аналогично, първата колона от таблицата ще отразява най-малката обща подредица на втория низ и празен низ.

След това започваме да попълваме останалите клетки на таблицата. Ако символите на i-тия и j-тия елемент на двете низа съвпадат, тогава добавяме този символ към текущата най-малка обща подредица и преминаваме към следващите елементи на двете низа. Ако символите не съвпадат, тогава трябва да се вземе решение, дали да се добави символът от първия низ или от втория низ в текущата най-малка обща подредица. Това се прави като се сравнят двата възможни резултата и се избере най-малкият.

След като попълним цялата таблица, най-малката обща подредица на символите на двете низа ще бъде на последната клетка в таблицата.

7-В теорията на графите, граф е математически обект, който представлява съвкупност от върхове (nodes) и ребра (edges) между тях. Граф може да бъде ориентиран, когато ребрата му имат посока, или неориентиран, когато ребрата нямат посока.

Връх (vertex) е точка в графа, която е свързана с ребрата и може да има различни свойства като име, маркировка, стойност и т.н.

Ребро (edge) е връзка между два върха в графа. Ако графът е ориентиран, реброто има посока от началния връх към крайния, а в неориентирания граф реброто не има посока.

Път в графа е редица от върхове, свързани с ребра, като всяко ребро свързва съседни върхове в редицата.

Цикъл в графа е път, който започва и завършва в един и същ връх и съдържа поне едно ребро. В ориентиран граф, цикълът може да бъде затворен и да има повече от едно начало и край.

8-Обхождането в ширина (BFS - Breadth-First Search) и обхождането в дълбочина (DFS - Depth-First Search) са два основни алгоритъма за обхождане на графи.

При обхождането в ширина (BFS) се започва от даден връх и се обхождат всички негови съседи, след това се продължава с обхождането на съседите на тези съседи и т.н. до изчерпване на всички възможни върхове. Това означава, че BFS използва опашка за запомняне на върховете, които трябва да бъдат посетени.

При обхождането в дълбочина (DFS) се започва от даден връх и се обхождат всички негови съседи, след това се продължава с обхождането на един от съседите му и т.н. до изчерпване на всички възможни върхове. Това означава, че DFS използва стек за запомняне на върховете, които трябва да бъдат посетени.
