                                                        Разработка на софтуер Тема-7


1- Трислоен модел е архитектурен шаблон за дизайн на софтуерни приложения, който се състои от три отделни слоя: модел, изглед и контролер. В зависимост от конкретната реализация на модела, те могат да бъдат комбинирани по различни начини, но всяка версия обикновено спазва тази основна архитектура.

MVC (Model-View-Controller) е един от най-популярните трислоени модели в софтуерната индустрия. Той се използва главно за уеб приложения и се състои от следните компоненти:

(Model): този слой представлява бизнес логиката на приложението и управлява данните. Той може да включва данни от база данни, файлове или други източници. Моделът може да съдържа логика, която обработва и манипулира данните.

(View): този слой представя данните на потребителите. Той включва елементи за управление на потребителския интерфейс, като бутони, полета за въвеждане на текст и т.н. Изгледът може да бъде визуализиран като уеб страница или като приложение за десктоп или мобилно устройство.

(Controller): този слой свързва модела и изгледа. Той обработва заявки от потребителите и ги предава на модела за обработка. Когато моделът връща отговор, контролерът го препраща към изгледа за визуализация.

MVVM (Model-View-ViewModel) е друг трислоен модел, който се използва главно за мобилни и десктоп приложения. Той се състои от следните компоненти: Model, View и

ViewModel е моста между Model и View. Този слой обвива Model и предоставя интерфейс, който може да бъде използван от View за извличане на данни и промяна на състоянието на Model. ViewModel е също отговорен за извършването на валидация на данните и обработка на потребителски вход.

графично: mvc     input-> controller -> view                             mvvm       input -> view -> view model <-> model
                              |    
                             \ /        / \
                              model ->   |


3-Видовете тествания са множество техники, използвани за проверка на софтуерни системи и устройства с цел увереност в тяхната коректност и работоспособност. Тестванията могат да бъдат разделени на няколко категории, според различните аспекти, които се оценяват:

По начина на изпълнение:

Ръчни тестове - изпълняват се от хора и се основават на технически умения, интуиция и опит. Могат да бъдат трудни за организиране и изискват значителни човешки ресурси, но позволяват разнообразни и нестандартни проверки.
Автоматизирани тестове - изпълняват се от компютърни програми и могат да бъдат автоматизирани, оптимизирани и мащабирани. Обикновено изискват по-високо техническо ниво, но позволяват по-голяма точност и скорост на изпълнение.
По ниво на тестване:

Unit тестове - тестват индивидуални части от софтуерната система (функции, методи, класове) за изолирани случаи, с цел да се уверим, че те работят правилно и отговарят на спецификациите си.
Integration тестове - тестват взаимодействието между различните части на софтуерната система, за да се уверим, че те могат да комуникират и да работят заедно правилно.
System тестове - тестват цялата система като единно цяло, за да се уверим, че тя отговаря на изискванията и очакванията на потребителите.
Acceptance тестове - тестват системата от гледна точка на потребителите и клиентите, за да се уверим, че тя отговаря на техните нужди и изисквания.

4-Code First и Database First са два различни подхода за разработка на софтуерни приложения, където всякакъв тип данни, логика и схеми трябва да се запишат в базата данни.

При Code First, разработчикът първо дефинира моделите на данните в своя код, а след това използва инструменти като Entity Framework, за да създаде базата данни, която отговаря на тези модели. Това позволява на разработчика да започне с разработването на приложението, без да се притеснява за базата данни.

При Database First, разработчикът първо проектира базата данни, като използва инструменти като SQL Server Management Studio или Oracle SQL Developer, и след това използва Entity Framework, за да създаде моделите на данните, които съответстват на тази база данни.

Основната разлика между тези два подхода е в това, кой от тях създава структурата на базата данни. Code First е по-гъвкав и позволява на разработчика да добавя, променя и премахва лесно моделите на данни, а след това да създаде базата данни, която отговаря на тези модели. Database First е по-ограничен и изисква да се проектира базата данни предварително, преди да се създадат моделите на данните.

При Code First процесът на разработка включва дефиниране на моделите на данните, създаване на миграции, които автоматично генерират SQL за промяна на структурата на базата данни, и публикуване на миграциите в базата данни.

При Database First процесът на разработка включва проектиране на базата данни, генериране на моделите на данните, които съответстват на тази база данни, и интегриране на тези модели в приложението.

Изборът на подход зависи от конкретните изисквания на проекта и предпочитанията на разработчика. Code First е по-подходящ за проекти, където е необходимо гъвкавост и често промяна на структурата на базата данни, докато Database First е по-подходящ за проекти, където проектирането на базата данни е критично и е необходимо да се изгради точна и пълна структура преди да се започне програмирането.

При Code First подхода процесът на разработка е по-гъвкав, тъй като първо се проектира модела на данните, а след това се генерира базата данни. Това позволява на разработчиците да променят структурата на базата данни по време на разработката, без да е необходимо да правят големи промени в кода. Процесът на разработка може да бъде по-бърз, тъй като няма необходимост да се изгражда база данни преди да се започне програмирането.

При Database First подхода процесът на разработка започва с проектиране на базата данни и генериране на модел на данните. Това позволява на разработчиците да имат точна представа за структурата на базата данни преди да започнат да програмират. Този подход е по-подходящ за големи и сложни проекти, където точността в проектирането на базата данни е критична.

В допълнение, Code First подходът може да бъде по-подходящ за независими разработчици или малки екипи, които имат по-малко специализирани умения в проектирането на бази данни, тъй като те могат да се фокусират върху програмния код, докато базата данни се генерира автоматично.

С друга страна, Database First подходът може да бъде по-подходящ за по-големи екипи, които разполагат със специализирани бази данни администратори и/или проектанти на бази данни, тъй като те могат да се фокусират върху проектирането на структурата на базата данни, което може да подобри производителността и скалируемостта на приложението.

5-За да разработим приложение, което да работи с база данни, можем да изберем да следваме подхода Code First или Database First. За да илюстрираме процеса на разработка, ще разгледаме пример за Code First подхода.

Ще създадем просто приложение, което да поддържа съхранение на информацията за потребители. За целта, първо ще създадем клас User, който ще представлява таблица в базата данни.

data User = User
  { userId :: Int
  , username :: String
  , email :: String
  } deriving (Show, Eq)

След това, ще дефинираме контекста на базата данни, който ще съдържа таблицата Users. За целта, ще използваме библиотеката persistent.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE TemplateHaskell #-}

import Database.Persist.Sqlite
import Database.Persist.TH

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
User
  username String
  email String
  deriving Show
|]

След като сме дефинирали контекста на базата данни, можем да генерираме миграциите с помощта на migrateAll.

main :: IO ()
main = runSqlite "users.db" $ do
    runMigration migrateAll

Това ще генерира таблицата users в базата данни users.db. Сега можем да започнем да използваме базата данни в нашето приложение.

import Control.Monad.IO.Class (liftIO)

getUser :: Int -> IO (Maybe User)
getUser id = runSqlite "users.db" $ do
    user <- get $ toSqlKey $ fromIntegral id
    return $ entityVal <$> user

createUser :: User -> IO (Key User)
createUser user = runSqlite "users.db" $ insert user

updateUser :: Int -> User -> IO ()
updateUser id user = runSqlite "users.db" $ do
    update $ toSqlKey $ fromIntegral id
           [ UserUsername =. username user
           , UserEmail =. email user
           ]

deleteUser :: Int -> IO ()
deleteUser id = runSqlite "users.db" $ delete $ toSqlKey $ fromIntegral id

Тук дефинираме функции за работа с базата данни. getUser връща потребителя с даденото id, createUser добавя нов потребител към базата данни, updateUser обновява потребителя с даденото id, а deleteUser изтрива потребителя с даденото id.

6-ORM (Object-Relational Mapping) е технология, която предоставя абстракция над база от данни и позволява да работим с данните като с обекти в програмния език. При използването на ORM технология, заявките към базата от данни се генерират автоматично от ORM инструмента, базирани на дефинирани от нас модели на данните. В следствие на това, ORM технологията може да улесни работата с базата от данни, като предоставя по-високо ниво на абстракция и удобен начин за манипулиране на данните.

SQL (Structured Query Language) е стандартен език за манипулиране на релационни бази данни. Заявките на SQL са написани във формат на текст и включват операции като SELECT, INSERT, UPDATE, DELETE и др. При работата с база от данни чрез SQL заявки, трябва да се внимава с детайлите като правилното писане на заявките, използването на правилните типове данни и други.

За да демонстрираме работата с ORM технология, ще използваме библиотеката Entity Framework за .NET. Entity Framework е ORM инструмент, който предоставя абстракция над база от данни и улеснява работата с нея.

Ще демонстрираме примерна работа с база от данни, като ще използваме модел на данните и ще добавим нов запис в таблицата чрез Entity Framework.

Първо, ще дефинираме модел на данните:

public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
}

След това, ще създадем контекст за базата данни, който ще използва модела на данните:

public class MyDbContext : DbContext
{
    public DbSet<Product> Products { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer("Server=(localdb)\\mssqllocaldb;Database=MyDb;Trusted_Connection=True;");
    }
}

В този пример използваме Microsoft SQL Server и ще конфигурираме контекста да използва тази база от данни.

Сега, когато имаме дефиниран модел на данните и контекста за базата данни, можем да използваме ORM технологията за да създадем, променим или изтрием данни в базата данни.

Нека разгледаме пример с използване на ORM технологията Entity Framework Core. Предположете, че имаме следния модел на данни за базата ни:

public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
}

След това можем да създадем контекста за базата ни, който наследява класа DbContext и представя таблицата в базата ни:

public class MyDbContext : DbContext
{
    public DbSet<Product> Products { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer("connection_string_to_database");
    }
}

Сега, когато имаме дефиниран модел на данните и контекста за базата данни, можем да използваме ORM технологията за да изпълним заявки към базата данни. Ето примери за това как бихме могли да изпълним заявки към таблицата Products:

using (var db = new MyDbContext())
{
    // Извличане на всички записи от таблицата Products
    var products = db.Products.ToList();

    // Извличане на продукт по зададен Id
    var product = db.Products.FirstOrDefault(p => p.Id == 1);

    // Добавяне на нов продукт
    db.Products.Add(new Product { Name = "New Product", Price = 10.99m });
    db.SaveChanges();

    // Промяна на цената на продукт с Id 2
    var productToUpdate = db.Products.FirstOrDefault(p => p.Id == 2);
    productToUpdate.Price = 19.99m;
    db.SaveChanges();

    // Изтриване на продукт с Id 3
    var productToDelete = db.Products.FirstOrDefault(p => p.Id == 3);
    db.Products.Remove(productToDelete);
    db.SaveChanges();
}

Тук сме използвали ORM технологията, за да извършим всички операции върху таблицата Products. ORM технологията ни осигурява абстракция над базата данни, така че не е нужно да пишем SQL заявки направо. Вместо това използваме методи на контекста, които да изпълнят нужните действия.

Операциите, които извършваме в този пример, могат да бъдат изпълнени и чрез написване на ръчни SQL заявки. Например, ако използваме Entity Framework Code First, можем да извършим CRUD (Create, Read, Update, Delete) операции върху базата данни с помощта на следните методи:

Create: context.Add(entity) и context.SaveChanges()
Read: context.Set<Entity>().Find(id) или context.Set<Entity>().ToList()
Update: context.Update(entity) и context.SaveChanges()
Delete: context.Remove(entity) и context.SaveChanges()
Тези методи използват ORM технологията, за да генерират и изпълнят SQL заявки към базата данни. Но е важно да се отбележи, че при работа с ORM, заявките могат да бъдат оптимизирани, като се използват индекси, кеш и други методи за подобряване на производителността на заявките.

От друга страна, когато използваме SQL заявки директно, трябва да се грижим сами за оптимизирането на заявките, за да подобрим производителността на приложението. Това може да бъде извършено чрез използване на индекси, оптимизиране на заявките, избягване на излишни заявки и други техники.

7-Пакетът е единица за доставка на софтуер, която съдържа една или повече програми, библиотеки, настройки или други компоненти. Пакетният мениджър е програмен инструмент, който управлява процеса на инсталиране, обновяване и премахване на пакети в операционната система.

В много операционни системи, като например Linux и macOS, има вградени пакетни мениджъри, като например apt-get в Ubuntu и Debian, yum в Red Hat и CentOS и Homebrew в macOS. В Windows има няколко пакетни мениджъра налични за използване, като например Chocolatey и NuGet.

За да инсталирате пакет, трябва да използвате пакетния мениджър на вашия операционна система. Например, ако използвате apt-get в Ubuntu, можете да инсталирате пакета "nano" (текстов редактор) като изпълните следната команда в терминала:

sudo apt-get install nano

Ако използвате Chocolatey в Windows, можете да инсталирате пакета "Git" (система за контрол на версиите) като изпълните следната команда в PowerShell:

choco install git

При работа с ORM технологии, като Entity Framework в .NET, ORM заявките се генерират автоматично от инструмента на базата данни, който е свързан към приложението. В този случай, ORM заявките не се пишат ръчно, а се генерират от инструмента. SQL заявките, от друга страна, се пишат ръчно от програмиста и се изпълняват директно върху базата данни. Обикновено, при използване на ORM, се използва специфичен пакетен мениджър, който предоставя удобен начин за инсталиране и управление на необходимите пакети. Най-популярните пакетни мениджъри за различни програмни езици включват:

npm за Node.js
pip за Python
Maven за Java
NuGet за .NET

За да инсталираме пакет в проекта си, можем да използваме командния ред на съответния пакетен мениджър или да добавим нужния пакет във файла с зависимости на проекта (като package.json за npm или requirements.txt за pip).

Например, ако работим с Node.js и искаме да инсталираме пакета "axios", който предоставя удобни функции за изпращане на HTTP заявки, можем да изпълним следната команда:

npm install axios

Това ще инсталира пакета "axios" и ще го добави към списъка с зависимости във файла package.json.

При избора на подходящи пакети за конкретна задача е важно да изследваме различните опции и да проверим документацията и ревюта от други потребители. Можем да търсим пакети в официалните репозитории на съответния пакетен мениджър или в отворените репозитории на GitHub и други подобни сайтове. Когато изберем подходящия пакет, можем да го инсталираме и да започнем да го използваме в нашия проект.