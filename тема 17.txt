                                                    Функционално програмиране Тема-17


1-Функционалната парадигма на програмиране е модел на програмиране, който се фокусира върху функциите като основен елемент за постигане на желаното поведение на програмата. В тази парадигма, функциите имат математически характер и са чисти, т.е. те не променят състоянието на програмата и не зависят от други фактори освен от входните им параметри.

Основните принципи на функционалната парадигма включват:

Функциите като основен строителен блок за постигане на желаното поведение на програмата.
Използване на рекурсия вместо цикли за повторяемост на операции.
Използване на чисти функции, които не променят състоянието на програмата.
Използване на функционални структури от данни, като списъци и множества.
Използване на високоредовни функции, които приемат други функции като параметри и/или връщат функции като резултат.
Функционалната парадигма се различава от процедурната парадигма, която се фокусира върху процедурите (функциите), които променят състоянието на програмата. В обектно-ориентираната парадигма, фокусът е върху обектите, които съдържат данни и методи за манипулиране на тези данни.

Значението на функционалната парадигма на програмиране се изразява в нейната способност да улеснява проектирането и тестването на програмите, като функциите в нея са лесни за тестване, поради тяхната чистота. Освен това, функционалната парадигма позволява паралелно изпълнение на кода, което може да подобри бързодействието на програмата. Тя е подходяща за програмиране на функции с много параметри, които да вършат сложни математически операции.

2-В програмирането терминът "страничен ефект" се използва за описване на всякакъв вид взаимодействие на една функция със средата, извън рамките на своята функционалност, което може да доведе до непредвидени последствия. Когато функцията извършва някаква операция, която променя стойността на променлива извън своята обхват, това може да доведе до непредвидими последствия за останалата част от програмата, която използва тази променлива. Страничният ефект може да се прояви във всякакви форми, като променяне на стойности на променливи, извикване на други функции, изход на данни на конзолата или на екрана, запис във файл и т.н. Това може да доведе до по-сложни и грешковити програми и затруднява отстраняването на грешки.

3-Входно/изходните операции (Input/Output, I/O) са важна част от програмирането, тъй като те позволяват на програмата да комуникира с външния свят. В функционалното програмиране, като част от функционалната парадигма, I/O е малко по-различно от другите парадигми, като процедурната или обектно-ориентирана, тъй като функциите в функционалното програмиране са без странични ефекти.

За извършване на входно/изходни операции в функционален език можем да използваме монади. Монадите са абстрактни типове данни, които позволяват на функциите да извършват I/O операции, като същевременно запазват функционалните им свойства.

В Haskell, един от най-известните функционални езици, един от начините за извършване на входно/изходни операции е с използване на монадата IO. Например, за четене на потребителски вход от конзолата можем да използваме функцията getLine, която връща стойност от тип IO String:

getLine :: IO String

Тази функция изчаква потребителя да въведе ред от конзолата и връща резултата като String. За да използваме стойността на getLine, можем да използваме оператора ">>=" (bind), който свързва IO стойности с други IO действия:

main :: IO ()
main = do
  putStrLn "What is your name?"
  name <- getLine
  putStrLn ("Hello, " ++ name ++ "!")

Тук, функцията putStrLn изпълнява I/O операцията да изведе текст на екрана, след което getLine чете входа на потребителя и го свързва с името name. След това се изпълнява функцията putStrLn, която отново извършва I/O операцията да изведе текст на екрана.

4-Понятието "състояние" на програма се отнася до текущото състояние на изпълнението на програмата в даден момент от време. То включва стойностите на всички променливи, обекти и други структури, които са в паметта на програмата в дадения момент.

Например, ако имаме програма за изчисляване на сумата на две числа, състоянието на програмата в даден момент включва стойностите на двете числа, които се изчисляват, както и стойността на променливата, която държи резултата. Състоянието на програмата се променя с всеки нов вход или при изпълнение на инструкции, които променят стойностите на променливите и обектите.

Състоянието на програмата е от съществено значение при отстраняване на грешки в програмата. За да се намери проблемът, разработчикът може да проследи състоянието на програмата при изпълнение и да установи къде стойностите на променливите или обектите не съответстват на очакванията. Освен това, в многонишкови или разпределени приложения, състоянието на програмата може да бъде споделено между няколко нишки или процеса, което може да доведе до състояния на състоянията или други проблеми, свързани с конкурентното изпълнение.
Така че, вместо да променяме стойностите на променливи, функционалните езици за програмиране използват монади за извършване на I/O операции, като запазват функционалните им свойства.

5-Функциите в програмирането представляват блокове от код, който може да бъде изпълнен многократно, като му се подават различни аргументи. Те са полезни за абстрактиране на логически блокове от кода и ги правят по-лесни за поддръжка и разбиране.

Създаването на функции се извършва по следния начин:

def функция(аргумент1, аргумент2):
    # тяло на функцията
    return резултат

Където:

def е ключова дума за дефиниране на функция
функция е името на функцията, което може да бъде както вградено, така и зададено от потребителя
аргумент1 и аргумент2 са параметрите, които приема функцията
# тяло на функцията са инструкциите, които функцията изпълнява
return е ключова дума, която връща стойността на функцията
Пример:

def square(x):
    return x ** 2

result = square(5)
print(result)  # извежда 25

Тук създаваме функция square, която взима аргумент x и връща квадрата му. След това използваме функцията, като подаваме аргумент 5 и извеждаме резултата на екрана.

6-Рекурсията е техника в програмирането, при която функцията извиква сама себе си за решаване на определена задача. В функционалното програмиране рекурсията е широко използван метод за решаване на множество задачи, тъй като функциите в този тип езици са без състояние и нямат странични ефекти.

За да създадем рекурсивна функция, трябва да имаме два случая: базов случай и рекурсивен случай. Базовият случай представлява краен случай, който може да бъде решен директно, без да се извиква функцията отново. Рекурсивният случай представлява случай, в който функцията се извиква отново с по-малки или различни параметри, докато не се стигне до базовия случай.

Ето пример за рекурсивна функция, която пресмята факториел от дадено число:

let factorial n =
    if n = 0 then 1
    else n * factorial (n-1)

В този пример базовият случай е n = 0, при който функцията връща резултат 1. В рекурсивния случай функцията извиква себе си с аргумент n-1, докато не стигне до базовия случай.

Ето и друг пример за рекурсивна функция, която изчислява сумата на елементите в даден списък:

let rec sum lst =
    match lst with
    | [] -> 0
    | x :: xs -> x + sum xs

В този пример базовият случай е празният списък [], при който функцията връща резултат 0. В рекурсивния случай функцията извиква себе си с остатъка от списъка xs, като добавя първия елемент x към сумата на остатъка.

Рекурсията може да бъде мощен инструмент за решаване на много задачи в програмирането, но трябва да се внимава да не се попадне в безкраен цикъл (например, когато базовият случай не е достигнат).

7-Чиста функция (pure function) в програмирането е функция, която не променя състоянието на програмата и не зависи от външни фактори, освен от подадените й аргументи. Това означава, че при подадени едни и същи аргументи чистата функция връща един и същ резултат, без значение в какъв контекст се изпълнява функцията.

С други думи, чистите функции нямат странични ефекти и са детерминирани. Те не променят глобални променливи, не записват или четат от файлове или бази от данни и не извършват мрежови заявки. Поради това те са по-лесни за тестване, разбиране и поддръжка.

8-Обработката на списъци с функции е основен елемент в функционалното програмиране. Това е възможно благодарение на това, че списъците могат да бъдат обработвани като данни, подобно на числа или низове.

В функционалните езици за програмиране като Haskell и Scheme има много вградени функции за обработка на списъци, като map, filter, reduce и други. Ето няколко примера:

map - тази функция получава като аргумент друга функция и списък. Връща нов списък, като за всеки елемент от оригиналния списък прилага функцията и добавя резултата към новия списък. Например, ако искаме да удвоим всички елементи в списъка [1, 2, 3], можем да го направим по следния начин:

double x = x * 2
newList = map double [1, 2, 3] -- newList е [2, 4, 6]

filter - тази функция получава като аргумент предикатна функция (функция, която връща булев резултат) и списък. Връща нов списък, който съдържа само елементите на оригиналния списък, за които предикатната функция връща true. Например, ако искаме да филтрираме само четните числа в списъка [1, 2, 3, 4, 5], можем да го направим по следния начин:

isEven x = x `mod` 2 == 0
newList = filter isEven [1, 2, 3, 4, 5] -- newList е [2, 4]

reduce - тази функция получава като аргумент друга функция, списък и начална стойност. Връща резултатът от последователното прилагане на функцията върху всеки елемент от списъка и текущия резултат. Началната стойност се използва като първоначален резултат. Например, ако искаме да намерим сумата на елементите в списъка [1, 2, 3], можем да го направим по следния начин:

sumList acc x = acc + x
result = reduce sumList 0 [1, 2, 3] -- result е 6

9-Глава и опашка са две фундаментални понятия за работа със списъци в функционалното програмиране.

Главата на списъка е първият елемент на списъка, а опашката е всичко останало след първия елемент. Тоест, ако имаме списък [1, 2, 3, 4], то главата на списъка е 1, а опашката е [2, 3, 4].

Това понятие е важно за рекурсивните функции, когато искаме да работим с елементите на списък един по един. Можем да използваме главата, за да извършим дадено действие, а след това да извикаме рекурсивно функцията върху опашката на списъка, за да продължим работата със следващите елементи.

Пример за използване на глава и опашка е при сумиране на елементите на списък чрез рекурсия:

sumList :: [Int] -> Int
sumList [] = 0
sumList (x:xs) = x + sumList xs

В горния пример x е главата на списъка, а xs е опашката. Рекурсивно извикваме функцията sumList върху опашката xs, докато не стигнем до празен списък.